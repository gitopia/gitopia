// Generated by Ignite ignite.com/cli

import { StdFee } from "@cosmjs/launchpad";
import { SigningStargateClient, DeliverTxResponse } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { MsgUpdateMemberRole } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateUserAvatar } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgMultiSetTag } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgDeleteTag } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgToggleRepositoryArchived } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgSetBranch } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgForkRepositorySuccess } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgDeletePullRequest } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgDeleteRepositoryLabel } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgAddPullRequestLabels } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateUserUsername } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgSetTag } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgMultiDeleteTag } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgDeleteTask } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgDeleteRepository } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgRevokeProviderPermission } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgCreateRelease } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateUserBio } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateIssueDescription } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateDaoAvatar } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgMultiSetBranch } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgInvokeMergePullRequest } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgAddIssueLabels } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgCreateComment } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdatePullRequestDescription } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgAddPullRequestReviewers } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateTask } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgRenameRepository } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgToggleIssueState } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUnlinkPullRequestIssueByIid } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateRelease } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgDeleteRelease } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgCreateIssue } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgToggleRepositoryForking } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgRemovePullRequestLabels } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgForkRepository } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgToggleCommentResolved } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateUserName } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgDeleteBounty } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgCreateDao } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgRenameDao } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgAddMember } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateIssueTitle } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgChangeOwner } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgCreateRepositoryLabel } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgCreateTask } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgDeleteBranch } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgCreatePullRequest } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgInvokeForkRepository } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgRemoveIssueLabels } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgDistributePlatformIncentives } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateComment } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgDeleteUser } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgLinkPullRequestIssueByIid } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgAddIssueAssignees } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgExercise } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateUserPinnedRepositories } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgRemoveMember } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateBountyExpiry } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgRemovePullRequestReviewers } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgDeleteComment } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgCloseBounty } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgRemoveIssueAssignees } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateDaoWebsite } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateRepositoryDescription } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateRepositoryBackupRef } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgSetDefaultBranch } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgAddPullRequestAssignees } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateParams } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgToggleForcePush } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgToggleArweaveBackup } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdatePullRequestTitle } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateDaoDescription } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgDeleteIssue } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgCreateBounty } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgDeleteDao } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgCreateRepository } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgRemovePullRequestAssignees } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgAddRepositoryBackupRef } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateDaoPinnedRepositories } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateRepositoryCollaborator } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgRemoveRepositoryCollaborator } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgAuthorizeProvider } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgMultiDeleteBranch } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateRepositoryLabel } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgCreateUser } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgSetPullRequestState } from "./types/gitopia/gitopia/gitopia/tx";
import { MsgUpdateDaoLocation } from "./types/gitopia/gitopia/gitopia/tx";

import { Attachment as typeAttachment} from "./types"
import { Bounty as typeBounty} from "./types"
import { Branch as typeBranch} from "./types"
import { Comment as typeComment} from "./types"
import { Dao as typeDao} from "./types"
import { ExercisedAmount as typeExercisedAmount} from "./types"
import { Issue as typeIssue} from "./types"
import { Member as typeMember} from "./types"
import { DistributionProportion as typeDistributionProportion} from "./types"
import { PoolProportions as typePoolProportions} from "./types"
import { Params as typeParams} from "./types"
import { PullRequest as typePullRequest} from "./types"
import { PullRequestHead as typePullRequestHead} from "./types"
import { PullRequestBase as typePullRequestBase} from "./types"
import { QueryGetPullRequestRequest as typeQueryGetPullRequestRequest} from "./types"
import { QueryGetPullRequestResponse as typeQueryGetPullRequestResponse} from "./types"
import { IssueOptions as typeIssueOptions} from "./types"
import { PullRequestOptions as typePullRequestOptions} from "./types"
import { RepositoryFork as typeRepositoryFork} from "./types"
import { Reaction as typeReaction} from "./types"
import { Release as typeRelease} from "./types"
import { Repository as typeRepository} from "./types"
import { RepositoryId as typeRepositoryId} from "./types"
import { BaseRepositoryKey as typeBaseRepositoryKey} from "./types"
import { RepositoryOwner as typeRepositoryOwner} from "./types"
import { IssueIid as typeIssueIid} from "./types"
import { PullRequestIid as typePullRequestIid} from "./types"
import { RepositoryCollaborator as typeRepositoryCollaborator} from "./types"
import { RepositoryLabel as typeRepositoryLabel} from "./types"
import { RepositoryRelease as typeRepositoryRelease} from "./types"
import { RepositoryBackup as typeRepositoryBackup} from "./types"
import { Tag as typeTag} from "./types"
import { Task as typeTask} from "./types"
import { MsgDeleteStorageProviderResponse as typeMsgDeleteStorageProviderResponse} from "./types"
import { MsgSetBranch_Branch as typeMsgSetBranch_Branch} from "./types"
import { MsgMultiSetBranch_Branch as typeMsgMultiSetBranch_Branch} from "./types"
import { MsgSetTag_Tag as typeMsgSetTag_Tag} from "./types"
import { MsgMultiSetTag_Tag as typeMsgMultiSetTag_Tag} from "./types"
import { MsgDistributePlatformIncentives_Address as typeMsgDistributePlatformIncentives_Address} from "./types"
import { User as typeUser} from "./types"
import { UserDao as typeUserDao} from "./types"
import { Whois as typeWhois} from "./types"

export { MsgUpdateMemberRole, MsgUpdateUserAvatar, MsgMultiSetTag, MsgDeleteTag, MsgToggleRepositoryArchived, MsgSetBranch, MsgForkRepositorySuccess, MsgDeletePullRequest, MsgDeleteRepositoryLabel, MsgAddPullRequestLabels, MsgUpdateUserUsername, MsgSetTag, MsgMultiDeleteTag, MsgDeleteTask, MsgDeleteRepository, MsgRevokeProviderPermission, MsgCreateRelease, MsgUpdateUserBio, MsgUpdateIssueDescription, MsgUpdateDaoAvatar, MsgMultiSetBranch, MsgInvokeMergePullRequest, MsgAddIssueLabels, MsgCreateComment, MsgUpdatePullRequestDescription, MsgAddPullRequestReviewers, MsgUpdateTask, MsgRenameRepository, MsgToggleIssueState, MsgUnlinkPullRequestIssueByIid, MsgUpdateRelease, MsgDeleteRelease, MsgCreateIssue, MsgToggleRepositoryForking, MsgRemovePullRequestLabels, MsgForkRepository, MsgToggleCommentResolved, MsgUpdateUserName, MsgDeleteBounty, MsgCreateDao, MsgRenameDao, MsgAddMember, MsgUpdateIssueTitle, MsgChangeOwner, MsgCreateRepositoryLabel, MsgCreateTask, MsgDeleteBranch, MsgCreatePullRequest, MsgInvokeForkRepository, MsgRemoveIssueLabels, MsgDistributePlatformIncentives, MsgUpdateComment, MsgDeleteUser, MsgLinkPullRequestIssueByIid, MsgAddIssueAssignees, MsgExercise, MsgUpdateUserPinnedRepositories, MsgRemoveMember, MsgUpdateBountyExpiry, MsgRemovePullRequestReviewers, MsgDeleteComment, MsgCloseBounty, MsgRemoveIssueAssignees, MsgUpdateDaoWebsite, MsgUpdateRepositoryDescription, MsgUpdateRepositoryBackupRef, MsgSetDefaultBranch, MsgAddPullRequestAssignees, MsgUpdateParams, MsgToggleForcePush, MsgToggleArweaveBackup, MsgUpdatePullRequestTitle, MsgUpdateDaoDescription, MsgDeleteIssue, MsgCreateBounty, MsgDeleteDao, MsgCreateRepository, MsgRemovePullRequestAssignees, MsgAddRepositoryBackupRef, MsgUpdateDaoPinnedRepositories, MsgUpdateRepositoryCollaborator, MsgRemoveRepositoryCollaborator, MsgAuthorizeProvider, MsgMultiDeleteBranch, MsgUpdateRepositoryLabel, MsgCreateUser, MsgSetPullRequestState, MsgUpdateDaoLocation };

type sendMsgUpdateMemberRoleParams = {
  value: MsgUpdateMemberRole,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateUserAvatarParams = {
  value: MsgUpdateUserAvatar,
  fee?: StdFee,
  memo?: string
};

type sendMsgMultiSetTagParams = {
  value: MsgMultiSetTag,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteTagParams = {
  value: MsgDeleteTag,
  fee?: StdFee,
  memo?: string
};

type sendMsgToggleRepositoryArchivedParams = {
  value: MsgToggleRepositoryArchived,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetBranchParams = {
  value: MsgSetBranch,
  fee?: StdFee,
  memo?: string
};

type sendMsgForkRepositorySuccessParams = {
  value: MsgForkRepositorySuccess,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeletePullRequestParams = {
  value: MsgDeletePullRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteRepositoryLabelParams = {
  value: MsgDeleteRepositoryLabel,
  fee?: StdFee,
  memo?: string
};

type sendMsgAddPullRequestLabelsParams = {
  value: MsgAddPullRequestLabels,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateUserUsernameParams = {
  value: MsgUpdateUserUsername,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetTagParams = {
  value: MsgSetTag,
  fee?: StdFee,
  memo?: string
};

type sendMsgMultiDeleteTagParams = {
  value: MsgMultiDeleteTag,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteTaskParams = {
  value: MsgDeleteTask,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteRepositoryParams = {
  value: MsgDeleteRepository,
  fee?: StdFee,
  memo?: string
};

type sendMsgRevokeProviderPermissionParams = {
  value: MsgRevokeProviderPermission,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateReleaseParams = {
  value: MsgCreateRelease,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateUserBioParams = {
  value: MsgUpdateUserBio,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateIssueDescriptionParams = {
  value: MsgUpdateIssueDescription,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateDaoAvatarParams = {
  value: MsgUpdateDaoAvatar,
  fee?: StdFee,
  memo?: string
};

type sendMsgMultiSetBranchParams = {
  value: MsgMultiSetBranch,
  fee?: StdFee,
  memo?: string
};

type sendMsgInvokeMergePullRequestParams = {
  value: MsgInvokeMergePullRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgAddIssueLabelsParams = {
  value: MsgAddIssueLabels,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateCommentParams = {
  value: MsgCreateComment,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdatePullRequestDescriptionParams = {
  value: MsgUpdatePullRequestDescription,
  fee?: StdFee,
  memo?: string
};

type sendMsgAddPullRequestReviewersParams = {
  value: MsgAddPullRequestReviewers,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateTaskParams = {
  value: MsgUpdateTask,
  fee?: StdFee,
  memo?: string
};

type sendMsgRenameRepositoryParams = {
  value: MsgRenameRepository,
  fee?: StdFee,
  memo?: string
};

type sendMsgToggleIssueStateParams = {
  value: MsgToggleIssueState,
  fee?: StdFee,
  memo?: string
};

type sendMsgUnlinkPullRequestIssueByIidParams = {
  value: MsgUnlinkPullRequestIssueByIid,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateReleaseParams = {
  value: MsgUpdateRelease,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteReleaseParams = {
  value: MsgDeleteRelease,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateIssueParams = {
  value: MsgCreateIssue,
  fee?: StdFee,
  memo?: string
};

type sendMsgToggleRepositoryForkingParams = {
  value: MsgToggleRepositoryForking,
  fee?: StdFee,
  memo?: string
};

type sendMsgRemovePullRequestLabelsParams = {
  value: MsgRemovePullRequestLabels,
  fee?: StdFee,
  memo?: string
};

type sendMsgForkRepositoryParams = {
  value: MsgForkRepository,
  fee?: StdFee,
  memo?: string
};

type sendMsgToggleCommentResolvedParams = {
  value: MsgToggleCommentResolved,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateUserNameParams = {
  value: MsgUpdateUserName,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteBountyParams = {
  value: MsgDeleteBounty,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateDaoParams = {
  value: MsgCreateDao,
  fee?: StdFee,
  memo?: string
};

type sendMsgRenameDaoParams = {
  value: MsgRenameDao,
  fee?: StdFee,
  memo?: string
};

type sendMsgAddMemberParams = {
  value: MsgAddMember,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateIssueTitleParams = {
  value: MsgUpdateIssueTitle,
  fee?: StdFee,
  memo?: string
};

type sendMsgChangeOwnerParams = {
  value: MsgChangeOwner,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateRepositoryLabelParams = {
  value: MsgCreateRepositoryLabel,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateTaskParams = {
  value: MsgCreateTask,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteBranchParams = {
  value: MsgDeleteBranch,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreatePullRequestParams = {
  value: MsgCreatePullRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgInvokeForkRepositoryParams = {
  value: MsgInvokeForkRepository,
  fee?: StdFee,
  memo?: string
};

type sendMsgRemoveIssueLabelsParams = {
  value: MsgRemoveIssueLabels,
  fee?: StdFee,
  memo?: string
};

type sendMsgDistributePlatformIncentivesParams = {
  value: MsgDistributePlatformIncentives,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateCommentParams = {
  value: MsgUpdateComment,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteUserParams = {
  value: MsgDeleteUser,
  fee?: StdFee,
  memo?: string
};

type sendMsgLinkPullRequestIssueByIidParams = {
  value: MsgLinkPullRequestIssueByIid,
  fee?: StdFee,
  memo?: string
};

type sendMsgAddIssueAssigneesParams = {
  value: MsgAddIssueAssignees,
  fee?: StdFee,
  memo?: string
};

type sendMsgExerciseParams = {
  value: MsgExercise,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateUserPinnedRepositoriesParams = {
  value: MsgUpdateUserPinnedRepositories,
  fee?: StdFee,
  memo?: string
};

type sendMsgRemoveMemberParams = {
  value: MsgRemoveMember,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateBountyExpiryParams = {
  value: MsgUpdateBountyExpiry,
  fee?: StdFee,
  memo?: string
};

type sendMsgRemovePullRequestReviewersParams = {
  value: MsgRemovePullRequestReviewers,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteCommentParams = {
  value: MsgDeleteComment,
  fee?: StdFee,
  memo?: string
};

type sendMsgCloseBountyParams = {
  value: MsgCloseBounty,
  fee?: StdFee,
  memo?: string
};

type sendMsgRemoveIssueAssigneesParams = {
  value: MsgRemoveIssueAssignees,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateDaoWebsiteParams = {
  value: MsgUpdateDaoWebsite,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateRepositoryDescriptionParams = {
  value: MsgUpdateRepositoryDescription,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateRepositoryBackupRefParams = {
  value: MsgUpdateRepositoryBackupRef,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetDefaultBranchParams = {
  value: MsgSetDefaultBranch,
  fee?: StdFee,
  memo?: string
};

type sendMsgAddPullRequestAssigneesParams = {
  value: MsgAddPullRequestAssignees,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsParams = {
  value: MsgUpdateParams,
  fee?: StdFee,
  memo?: string
};

type sendMsgToggleForcePushParams = {
  value: MsgToggleForcePush,
  fee?: StdFee,
  memo?: string
};

type sendMsgToggleArweaveBackupParams = {
  value: MsgToggleArweaveBackup,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdatePullRequestTitleParams = {
  value: MsgUpdatePullRequestTitle,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateDaoDescriptionParams = {
  value: MsgUpdateDaoDescription,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteIssueParams = {
  value: MsgDeleteIssue,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateBountyParams = {
  value: MsgCreateBounty,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteDaoParams = {
  value: MsgDeleteDao,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateRepositoryParams = {
  value: MsgCreateRepository,
  fee?: StdFee,
  memo?: string
};

type sendMsgRemovePullRequestAssigneesParams = {
  value: MsgRemovePullRequestAssignees,
  fee?: StdFee,
  memo?: string
};

type sendMsgAddRepositoryBackupRefParams = {
  value: MsgAddRepositoryBackupRef,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateDaoPinnedRepositoriesParams = {
  value: MsgUpdateDaoPinnedRepositories,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateRepositoryCollaboratorParams = {
  value: MsgUpdateRepositoryCollaborator,
  fee?: StdFee,
  memo?: string
};

type sendMsgRemoveRepositoryCollaboratorParams = {
  value: MsgRemoveRepositoryCollaborator,
  fee?: StdFee,
  memo?: string
};

type sendMsgAuthorizeProviderParams = {
  value: MsgAuthorizeProvider,
  fee?: StdFee,
  memo?: string
};

type sendMsgMultiDeleteBranchParams = {
  value: MsgMultiDeleteBranch,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateRepositoryLabelParams = {
  value: MsgUpdateRepositoryLabel,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateUserParams = {
  value: MsgCreateUser,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetPullRequestStateParams = {
  value: MsgSetPullRequestState,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateDaoLocationParams = {
  value: MsgUpdateDaoLocation,
  fee?: StdFee,
  memo?: string
};


type msgUpdateMemberRoleParams = {
  value: MsgUpdateMemberRole,
};

type msgUpdateUserAvatarParams = {
  value: MsgUpdateUserAvatar,
};

type msgMultiSetTagParams = {
  value: MsgMultiSetTag,
};

type msgDeleteTagParams = {
  value: MsgDeleteTag,
};

type msgToggleRepositoryArchivedParams = {
  value: MsgToggleRepositoryArchived,
};

type msgSetBranchParams = {
  value: MsgSetBranch,
};

type msgForkRepositorySuccessParams = {
  value: MsgForkRepositorySuccess,
};

type msgDeletePullRequestParams = {
  value: MsgDeletePullRequest,
};

type msgDeleteRepositoryLabelParams = {
  value: MsgDeleteRepositoryLabel,
};

type msgAddPullRequestLabelsParams = {
  value: MsgAddPullRequestLabels,
};

type msgUpdateUserUsernameParams = {
  value: MsgUpdateUserUsername,
};

type msgSetTagParams = {
  value: MsgSetTag,
};

type msgMultiDeleteTagParams = {
  value: MsgMultiDeleteTag,
};

type msgDeleteTaskParams = {
  value: MsgDeleteTask,
};

type msgDeleteRepositoryParams = {
  value: MsgDeleteRepository,
};

type msgRevokeProviderPermissionParams = {
  value: MsgRevokeProviderPermission,
};

type msgCreateReleaseParams = {
  value: MsgCreateRelease,
};

type msgUpdateUserBioParams = {
  value: MsgUpdateUserBio,
};

type msgUpdateIssueDescriptionParams = {
  value: MsgUpdateIssueDescription,
};

type msgUpdateDaoAvatarParams = {
  value: MsgUpdateDaoAvatar,
};

type msgMultiSetBranchParams = {
  value: MsgMultiSetBranch,
};

type msgInvokeMergePullRequestParams = {
  value: MsgInvokeMergePullRequest,
};

type msgAddIssueLabelsParams = {
  value: MsgAddIssueLabels,
};

type msgCreateCommentParams = {
  value: MsgCreateComment,
};

type msgUpdatePullRequestDescriptionParams = {
  value: MsgUpdatePullRequestDescription,
};

type msgAddPullRequestReviewersParams = {
  value: MsgAddPullRequestReviewers,
};

type msgUpdateTaskParams = {
  value: MsgUpdateTask,
};

type msgRenameRepositoryParams = {
  value: MsgRenameRepository,
};

type msgToggleIssueStateParams = {
  value: MsgToggleIssueState,
};

type msgUnlinkPullRequestIssueByIidParams = {
  value: MsgUnlinkPullRequestIssueByIid,
};

type msgUpdateReleaseParams = {
  value: MsgUpdateRelease,
};

type msgDeleteReleaseParams = {
  value: MsgDeleteRelease,
};

type msgCreateIssueParams = {
  value: MsgCreateIssue,
};

type msgToggleRepositoryForkingParams = {
  value: MsgToggleRepositoryForking,
};

type msgRemovePullRequestLabelsParams = {
  value: MsgRemovePullRequestLabels,
};

type msgForkRepositoryParams = {
  value: MsgForkRepository,
};

type msgToggleCommentResolvedParams = {
  value: MsgToggleCommentResolved,
};

type msgUpdateUserNameParams = {
  value: MsgUpdateUserName,
};

type msgDeleteBountyParams = {
  value: MsgDeleteBounty,
};

type msgCreateDaoParams = {
  value: MsgCreateDao,
};

type msgRenameDaoParams = {
  value: MsgRenameDao,
};

type msgAddMemberParams = {
  value: MsgAddMember,
};

type msgUpdateIssueTitleParams = {
  value: MsgUpdateIssueTitle,
};

type msgChangeOwnerParams = {
  value: MsgChangeOwner,
};

type msgCreateRepositoryLabelParams = {
  value: MsgCreateRepositoryLabel,
};

type msgCreateTaskParams = {
  value: MsgCreateTask,
};

type msgDeleteBranchParams = {
  value: MsgDeleteBranch,
};

type msgCreatePullRequestParams = {
  value: MsgCreatePullRequest,
};

type msgInvokeForkRepositoryParams = {
  value: MsgInvokeForkRepository,
};

type msgRemoveIssueLabelsParams = {
  value: MsgRemoveIssueLabels,
};

type msgDistributePlatformIncentivesParams = {
  value: MsgDistributePlatformIncentives,
};

type msgUpdateCommentParams = {
  value: MsgUpdateComment,
};

type msgDeleteUserParams = {
  value: MsgDeleteUser,
};

type msgLinkPullRequestIssueByIidParams = {
  value: MsgLinkPullRequestIssueByIid,
};

type msgAddIssueAssigneesParams = {
  value: MsgAddIssueAssignees,
};

type msgExerciseParams = {
  value: MsgExercise,
};

type msgUpdateUserPinnedRepositoriesParams = {
  value: MsgUpdateUserPinnedRepositories,
};

type msgRemoveMemberParams = {
  value: MsgRemoveMember,
};

type msgUpdateBountyExpiryParams = {
  value: MsgUpdateBountyExpiry,
};

type msgRemovePullRequestReviewersParams = {
  value: MsgRemovePullRequestReviewers,
};

type msgDeleteCommentParams = {
  value: MsgDeleteComment,
};

type msgCloseBountyParams = {
  value: MsgCloseBounty,
};

type msgRemoveIssueAssigneesParams = {
  value: MsgRemoveIssueAssignees,
};

type msgUpdateDaoWebsiteParams = {
  value: MsgUpdateDaoWebsite,
};

type msgUpdateRepositoryDescriptionParams = {
  value: MsgUpdateRepositoryDescription,
};

type msgUpdateRepositoryBackupRefParams = {
  value: MsgUpdateRepositoryBackupRef,
};

type msgSetDefaultBranchParams = {
  value: MsgSetDefaultBranch,
};

type msgAddPullRequestAssigneesParams = {
  value: MsgAddPullRequestAssignees,
};

type msgUpdateParamsParams = {
  value: MsgUpdateParams,
};

type msgToggleForcePushParams = {
  value: MsgToggleForcePush,
};

type msgToggleArweaveBackupParams = {
  value: MsgToggleArweaveBackup,
};

type msgUpdatePullRequestTitleParams = {
  value: MsgUpdatePullRequestTitle,
};

type msgUpdateDaoDescriptionParams = {
  value: MsgUpdateDaoDescription,
};

type msgDeleteIssueParams = {
  value: MsgDeleteIssue,
};

type msgCreateBountyParams = {
  value: MsgCreateBounty,
};

type msgDeleteDaoParams = {
  value: MsgDeleteDao,
};

type msgCreateRepositoryParams = {
  value: MsgCreateRepository,
};

type msgRemovePullRequestAssigneesParams = {
  value: MsgRemovePullRequestAssignees,
};

type msgAddRepositoryBackupRefParams = {
  value: MsgAddRepositoryBackupRef,
};

type msgUpdateDaoPinnedRepositoriesParams = {
  value: MsgUpdateDaoPinnedRepositories,
};

type msgUpdateRepositoryCollaboratorParams = {
  value: MsgUpdateRepositoryCollaborator,
};

type msgRemoveRepositoryCollaboratorParams = {
  value: MsgRemoveRepositoryCollaborator,
};

type msgAuthorizeProviderParams = {
  value: MsgAuthorizeProvider,
};

type msgMultiDeleteBranchParams = {
  value: MsgMultiDeleteBranch,
};

type msgUpdateRepositoryLabelParams = {
  value: MsgUpdateRepositoryLabel,
};

type msgCreateUserParams = {
  value: MsgCreateUser,
};

type msgSetPullRequestStateParams = {
  value: MsgSetPullRequestState,
};

type msgUpdateDaoLocationParams = {
  value: MsgUpdateDaoLocation,
};


export const registry = new Registry(msgTypes);

type Field = {
	name: string;
	type: unknown;
}
function getStructure(template) {
	const structure: {fields: Field[]} = { fields: [] }
	for (let [key, value] of Object.entries(template)) {
		let field = { name: key, type: typeof value }
		structure.fields.push(field)
	}
	return structure
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendMsgUpdateMemberRole({ value, fee, memo }: sendMsgUpdateMemberRoleParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateMemberRole: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateMemberRole({ value: MsgUpdateMemberRole.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateMemberRole: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateUserAvatar({ value, fee, memo }: sendMsgUpdateUserAvatarParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateUserAvatar: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateUserAvatar({ value: MsgUpdateUserAvatar.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateUserAvatar: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgMultiSetTag({ value, fee, memo }: sendMsgMultiSetTagParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgMultiSetTag: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgMultiSetTag({ value: MsgMultiSetTag.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgMultiSetTag: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteTag({ value, fee, memo }: sendMsgDeleteTagParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteTag: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteTag({ value: MsgDeleteTag.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteTag: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgToggleRepositoryArchived({ value, fee, memo }: sendMsgToggleRepositoryArchivedParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgToggleRepositoryArchived: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgToggleRepositoryArchived({ value: MsgToggleRepositoryArchived.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgToggleRepositoryArchived: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSetBranch({ value, fee, memo }: sendMsgSetBranchParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSetBranch: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgSetBranch({ value: MsgSetBranch.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSetBranch: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgForkRepositorySuccess({ value, fee, memo }: sendMsgForkRepositorySuccessParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgForkRepositorySuccess: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgForkRepositorySuccess({ value: MsgForkRepositorySuccess.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgForkRepositorySuccess: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeletePullRequest({ value, fee, memo }: sendMsgDeletePullRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeletePullRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeletePullRequest({ value: MsgDeletePullRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeletePullRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteRepositoryLabel({ value, fee, memo }: sendMsgDeleteRepositoryLabelParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteRepositoryLabel: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteRepositoryLabel({ value: MsgDeleteRepositoryLabel.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteRepositoryLabel: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAddPullRequestLabels({ value, fee, memo }: sendMsgAddPullRequestLabelsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAddPullRequestLabels: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgAddPullRequestLabels({ value: MsgAddPullRequestLabels.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAddPullRequestLabels: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateUserUsername({ value, fee, memo }: sendMsgUpdateUserUsernameParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateUserUsername: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateUserUsername({ value: MsgUpdateUserUsername.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateUserUsername: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSetTag({ value, fee, memo }: sendMsgSetTagParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSetTag: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgSetTag({ value: MsgSetTag.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSetTag: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgMultiDeleteTag({ value, fee, memo }: sendMsgMultiDeleteTagParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgMultiDeleteTag: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgMultiDeleteTag({ value: MsgMultiDeleteTag.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgMultiDeleteTag: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteTask({ value, fee, memo }: sendMsgDeleteTaskParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteTask: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteTask({ value: MsgDeleteTask.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteTask: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteRepository({ value, fee, memo }: sendMsgDeleteRepositoryParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteRepository: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteRepository({ value: MsgDeleteRepository.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteRepository: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRevokeProviderPermission({ value, fee, memo }: sendMsgRevokeProviderPermissionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRevokeProviderPermission: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgRevokeProviderPermission({ value: MsgRevokeProviderPermission.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRevokeProviderPermission: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateRelease({ value, fee, memo }: sendMsgCreateReleaseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateRelease: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateRelease({ value: MsgCreateRelease.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateRelease: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateUserBio({ value, fee, memo }: sendMsgUpdateUserBioParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateUserBio: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateUserBio({ value: MsgUpdateUserBio.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateUserBio: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateIssueDescription({ value, fee, memo }: sendMsgUpdateIssueDescriptionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateIssueDescription: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateIssueDescription({ value: MsgUpdateIssueDescription.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateIssueDescription: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateDaoAvatar({ value, fee, memo }: sendMsgUpdateDaoAvatarParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateDaoAvatar: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateDaoAvatar({ value: MsgUpdateDaoAvatar.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateDaoAvatar: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgMultiSetBranch({ value, fee, memo }: sendMsgMultiSetBranchParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgMultiSetBranch: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgMultiSetBranch({ value: MsgMultiSetBranch.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgMultiSetBranch: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgInvokeMergePullRequest({ value, fee, memo }: sendMsgInvokeMergePullRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgInvokeMergePullRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgInvokeMergePullRequest({ value: MsgInvokeMergePullRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgInvokeMergePullRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAddIssueLabels({ value, fee, memo }: sendMsgAddIssueLabelsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAddIssueLabels: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgAddIssueLabels({ value: MsgAddIssueLabels.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAddIssueLabels: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateComment({ value, fee, memo }: sendMsgCreateCommentParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateComment: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateComment({ value: MsgCreateComment.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateComment: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdatePullRequestDescription({ value, fee, memo }: sendMsgUpdatePullRequestDescriptionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdatePullRequestDescription: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdatePullRequestDescription({ value: MsgUpdatePullRequestDescription.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdatePullRequestDescription: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAddPullRequestReviewers({ value, fee, memo }: sendMsgAddPullRequestReviewersParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAddPullRequestReviewers: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgAddPullRequestReviewers({ value: MsgAddPullRequestReviewers.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAddPullRequestReviewers: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateTask({ value, fee, memo }: sendMsgUpdateTaskParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateTask: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateTask({ value: MsgUpdateTask.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateTask: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRenameRepository({ value, fee, memo }: sendMsgRenameRepositoryParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRenameRepository: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgRenameRepository({ value: MsgRenameRepository.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRenameRepository: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgToggleIssueState({ value, fee, memo }: sendMsgToggleIssueStateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgToggleIssueState: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgToggleIssueState({ value: MsgToggleIssueState.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgToggleIssueState: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUnlinkPullRequestIssueByIid({ value, fee, memo }: sendMsgUnlinkPullRequestIssueByIidParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUnlinkPullRequestIssueByIid: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUnlinkPullRequestIssueByIid({ value: MsgUnlinkPullRequestIssueByIid.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUnlinkPullRequestIssueByIid: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateRelease({ value, fee, memo }: sendMsgUpdateReleaseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateRelease: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateRelease({ value: MsgUpdateRelease.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateRelease: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteRelease({ value, fee, memo }: sendMsgDeleteReleaseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteRelease: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteRelease({ value: MsgDeleteRelease.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteRelease: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateIssue({ value, fee, memo }: sendMsgCreateIssueParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateIssue: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateIssue({ value: MsgCreateIssue.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateIssue: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgToggleRepositoryForking({ value, fee, memo }: sendMsgToggleRepositoryForkingParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgToggleRepositoryForking: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgToggleRepositoryForking({ value: MsgToggleRepositoryForking.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgToggleRepositoryForking: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRemovePullRequestLabels({ value, fee, memo }: sendMsgRemovePullRequestLabelsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRemovePullRequestLabels: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgRemovePullRequestLabels({ value: MsgRemovePullRequestLabels.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRemovePullRequestLabels: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgForkRepository({ value, fee, memo }: sendMsgForkRepositoryParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgForkRepository: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgForkRepository({ value: MsgForkRepository.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgForkRepository: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgToggleCommentResolved({ value, fee, memo }: sendMsgToggleCommentResolvedParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgToggleCommentResolved: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgToggleCommentResolved({ value: MsgToggleCommentResolved.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgToggleCommentResolved: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateUserName({ value, fee, memo }: sendMsgUpdateUserNameParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateUserName: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateUserName({ value: MsgUpdateUserName.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateUserName: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteBounty({ value, fee, memo }: sendMsgDeleteBountyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteBounty: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteBounty({ value: MsgDeleteBounty.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteBounty: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateDao({ value, fee, memo }: sendMsgCreateDaoParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateDao: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateDao({ value: MsgCreateDao.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateDao: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRenameDao({ value, fee, memo }: sendMsgRenameDaoParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRenameDao: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgRenameDao({ value: MsgRenameDao.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRenameDao: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAddMember({ value, fee, memo }: sendMsgAddMemberParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAddMember: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgAddMember({ value: MsgAddMember.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAddMember: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateIssueTitle({ value, fee, memo }: sendMsgUpdateIssueTitleParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateIssueTitle: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateIssueTitle({ value: MsgUpdateIssueTitle.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateIssueTitle: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgChangeOwner({ value, fee, memo }: sendMsgChangeOwnerParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgChangeOwner: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgChangeOwner({ value: MsgChangeOwner.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgChangeOwner: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateRepositoryLabel({ value, fee, memo }: sendMsgCreateRepositoryLabelParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateRepositoryLabel: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateRepositoryLabel({ value: MsgCreateRepositoryLabel.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateRepositoryLabel: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateTask({ value, fee, memo }: sendMsgCreateTaskParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateTask: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateTask({ value: MsgCreateTask.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateTask: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteBranch({ value, fee, memo }: sendMsgDeleteBranchParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteBranch: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteBranch({ value: MsgDeleteBranch.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteBranch: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreatePullRequest({ value, fee, memo }: sendMsgCreatePullRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreatePullRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreatePullRequest({ value: MsgCreatePullRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreatePullRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgInvokeForkRepository({ value, fee, memo }: sendMsgInvokeForkRepositoryParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgInvokeForkRepository: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgInvokeForkRepository({ value: MsgInvokeForkRepository.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgInvokeForkRepository: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRemoveIssueLabels({ value, fee, memo }: sendMsgRemoveIssueLabelsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRemoveIssueLabels: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgRemoveIssueLabels({ value: MsgRemoveIssueLabels.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRemoveIssueLabels: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDistributePlatformIncentives({ value, fee, memo }: sendMsgDistributePlatformIncentivesParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDistributePlatformIncentives: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDistributePlatformIncentives({ value: MsgDistributePlatformIncentives.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDistributePlatformIncentives: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateComment({ value, fee, memo }: sendMsgUpdateCommentParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateComment: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateComment({ value: MsgUpdateComment.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateComment: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteUser({ value, fee, memo }: sendMsgDeleteUserParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteUser: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteUser({ value: MsgDeleteUser.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteUser: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgLinkPullRequestIssueByIid({ value, fee, memo }: sendMsgLinkPullRequestIssueByIidParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgLinkPullRequestIssueByIid: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgLinkPullRequestIssueByIid({ value: MsgLinkPullRequestIssueByIid.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgLinkPullRequestIssueByIid: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAddIssueAssignees({ value, fee, memo }: sendMsgAddIssueAssigneesParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAddIssueAssignees: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgAddIssueAssignees({ value: MsgAddIssueAssignees.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAddIssueAssignees: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgExercise({ value, fee, memo }: sendMsgExerciseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgExercise: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgExercise({ value: MsgExercise.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgExercise: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateUserPinnedRepositories({ value, fee, memo }: sendMsgUpdateUserPinnedRepositoriesParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateUserPinnedRepositories: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateUserPinnedRepositories({ value: MsgUpdateUserPinnedRepositories.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateUserPinnedRepositories: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRemoveMember({ value, fee, memo }: sendMsgRemoveMemberParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRemoveMember: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgRemoveMember({ value: MsgRemoveMember.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRemoveMember: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateBountyExpiry({ value, fee, memo }: sendMsgUpdateBountyExpiryParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateBountyExpiry: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateBountyExpiry({ value: MsgUpdateBountyExpiry.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateBountyExpiry: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRemovePullRequestReviewers({ value, fee, memo }: sendMsgRemovePullRequestReviewersParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRemovePullRequestReviewers: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgRemovePullRequestReviewers({ value: MsgRemovePullRequestReviewers.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRemovePullRequestReviewers: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteComment({ value, fee, memo }: sendMsgDeleteCommentParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteComment: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteComment({ value: MsgDeleteComment.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteComment: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCloseBounty({ value, fee, memo }: sendMsgCloseBountyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCloseBounty: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCloseBounty({ value: MsgCloseBounty.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCloseBounty: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRemoveIssueAssignees({ value, fee, memo }: sendMsgRemoveIssueAssigneesParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRemoveIssueAssignees: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgRemoveIssueAssignees({ value: MsgRemoveIssueAssignees.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRemoveIssueAssignees: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateDaoWebsite({ value, fee, memo }: sendMsgUpdateDaoWebsiteParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateDaoWebsite: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateDaoWebsite({ value: MsgUpdateDaoWebsite.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateDaoWebsite: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateRepositoryDescription({ value, fee, memo }: sendMsgUpdateRepositoryDescriptionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateRepositoryDescription: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateRepositoryDescription({ value: MsgUpdateRepositoryDescription.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateRepositoryDescription: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateRepositoryBackupRef({ value, fee, memo }: sendMsgUpdateRepositoryBackupRefParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateRepositoryBackupRef: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateRepositoryBackupRef({ value: MsgUpdateRepositoryBackupRef.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateRepositoryBackupRef: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSetDefaultBranch({ value, fee, memo }: sendMsgSetDefaultBranchParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSetDefaultBranch: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgSetDefaultBranch({ value: MsgSetDefaultBranch.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSetDefaultBranch: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAddPullRequestAssignees({ value, fee, memo }: sendMsgAddPullRequestAssigneesParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAddPullRequestAssignees: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgAddPullRequestAssignees({ value: MsgAddPullRequestAssignees.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAddPullRequestAssignees: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParams({ value, fee, memo }: sendMsgUpdateParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateParams({ value: MsgUpdateParams.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgToggleForcePush({ value, fee, memo }: sendMsgToggleForcePushParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgToggleForcePush: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgToggleForcePush({ value: MsgToggleForcePush.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgToggleForcePush: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgToggleArweaveBackup({ value, fee, memo }: sendMsgToggleArweaveBackupParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgToggleArweaveBackup: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgToggleArweaveBackup({ value: MsgToggleArweaveBackup.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgToggleArweaveBackup: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdatePullRequestTitle({ value, fee, memo }: sendMsgUpdatePullRequestTitleParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdatePullRequestTitle: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdatePullRequestTitle({ value: MsgUpdatePullRequestTitle.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdatePullRequestTitle: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateDaoDescription({ value, fee, memo }: sendMsgUpdateDaoDescriptionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateDaoDescription: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateDaoDescription({ value: MsgUpdateDaoDescription.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateDaoDescription: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteIssue({ value, fee, memo }: sendMsgDeleteIssueParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteIssue: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteIssue({ value: MsgDeleteIssue.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteIssue: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateBounty({ value, fee, memo }: sendMsgCreateBountyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateBounty: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateBounty({ value: MsgCreateBounty.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateBounty: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteDao({ value, fee, memo }: sendMsgDeleteDaoParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteDao: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgDeleteDao({ value: MsgDeleteDao.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteDao: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateRepository({ value, fee, memo }: sendMsgCreateRepositoryParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateRepository: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateRepository({ value: MsgCreateRepository.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateRepository: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRemovePullRequestAssignees({ value, fee, memo }: sendMsgRemovePullRequestAssigneesParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRemovePullRequestAssignees: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgRemovePullRequestAssignees({ value: MsgRemovePullRequestAssignees.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRemovePullRequestAssignees: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAddRepositoryBackupRef({ value, fee, memo }: sendMsgAddRepositoryBackupRefParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAddRepositoryBackupRef: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgAddRepositoryBackupRef({ value: MsgAddRepositoryBackupRef.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAddRepositoryBackupRef: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateDaoPinnedRepositories({ value, fee, memo }: sendMsgUpdateDaoPinnedRepositoriesParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateDaoPinnedRepositories: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateDaoPinnedRepositories({ value: MsgUpdateDaoPinnedRepositories.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateDaoPinnedRepositories: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateRepositoryCollaborator({ value, fee, memo }: sendMsgUpdateRepositoryCollaboratorParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateRepositoryCollaborator: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateRepositoryCollaborator({ value: MsgUpdateRepositoryCollaborator.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateRepositoryCollaborator: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRemoveRepositoryCollaborator({ value, fee, memo }: sendMsgRemoveRepositoryCollaboratorParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRemoveRepositoryCollaborator: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgRemoveRepositoryCollaborator({ value: MsgRemoveRepositoryCollaborator.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRemoveRepositoryCollaborator: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAuthorizeProvider({ value, fee, memo }: sendMsgAuthorizeProviderParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAuthorizeProvider: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgAuthorizeProvider({ value: MsgAuthorizeProvider.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAuthorizeProvider: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgMultiDeleteBranch({ value, fee, memo }: sendMsgMultiDeleteBranchParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgMultiDeleteBranch: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgMultiDeleteBranch({ value: MsgMultiDeleteBranch.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgMultiDeleteBranch: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateRepositoryLabel({ value, fee, memo }: sendMsgUpdateRepositoryLabelParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateRepositoryLabel: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateRepositoryLabel({ value: MsgUpdateRepositoryLabel.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateRepositoryLabel: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateUser({ value, fee, memo }: sendMsgCreateUserParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateUser: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateUser({ value: MsgCreateUser.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateUser: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSetPullRequestState({ value, fee, memo }: sendMsgSetPullRequestStateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSetPullRequestState: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgSetPullRequestState({ value: MsgSetPullRequestState.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSetPullRequestState: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateDaoLocation({ value, fee, memo }: sendMsgUpdateDaoLocationParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateDaoLocation: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateDaoLocation({ value: MsgUpdateDaoLocation.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateDaoLocation: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		msgUpdateMemberRole({ value }: msgUpdateMemberRoleParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateMemberRole", value: MsgUpdateMemberRole.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateMemberRole: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateUserAvatar({ value }: msgUpdateUserAvatarParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateUserAvatar", value: MsgUpdateUserAvatar.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateUserAvatar: Could not create message: ' + e.message)
			}
		},
		
		msgMultiSetTag({ value }: msgMultiSetTagParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgMultiSetTag", value: MsgMultiSetTag.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgMultiSetTag: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteTag({ value }: msgDeleteTagParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgDeleteTag", value: MsgDeleteTag.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteTag: Could not create message: ' + e.message)
			}
		},
		
		msgToggleRepositoryArchived({ value }: msgToggleRepositoryArchivedParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgToggleRepositoryArchived", value: MsgToggleRepositoryArchived.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgToggleRepositoryArchived: Could not create message: ' + e.message)
			}
		},
		
		msgSetBranch({ value }: msgSetBranchParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgSetBranch", value: MsgSetBranch.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSetBranch: Could not create message: ' + e.message)
			}
		},
		
		msgForkRepositorySuccess({ value }: msgForkRepositorySuccessParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgForkRepositorySuccess", value: MsgForkRepositorySuccess.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgForkRepositorySuccess: Could not create message: ' + e.message)
			}
		},
		
		msgDeletePullRequest({ value }: msgDeletePullRequestParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgDeletePullRequest", value: MsgDeletePullRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeletePullRequest: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteRepositoryLabel({ value }: msgDeleteRepositoryLabelParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgDeleteRepositoryLabel", value: MsgDeleteRepositoryLabel.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteRepositoryLabel: Could not create message: ' + e.message)
			}
		},
		
		msgAddPullRequestLabels({ value }: msgAddPullRequestLabelsParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgAddPullRequestLabels", value: MsgAddPullRequestLabels.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAddPullRequestLabels: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateUserUsername({ value }: msgUpdateUserUsernameParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateUserUsername", value: MsgUpdateUserUsername.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateUserUsername: Could not create message: ' + e.message)
			}
		},
		
		msgSetTag({ value }: msgSetTagParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgSetTag", value: MsgSetTag.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSetTag: Could not create message: ' + e.message)
			}
		},
		
		msgMultiDeleteTag({ value }: msgMultiDeleteTagParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgMultiDeleteTag", value: MsgMultiDeleteTag.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgMultiDeleteTag: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteTask({ value }: msgDeleteTaskParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgDeleteTask", value: MsgDeleteTask.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteTask: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteRepository({ value }: msgDeleteRepositoryParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgDeleteRepository", value: MsgDeleteRepository.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteRepository: Could not create message: ' + e.message)
			}
		},
		
		msgRevokeProviderPermission({ value }: msgRevokeProviderPermissionParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgRevokeProviderPermission", value: MsgRevokeProviderPermission.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRevokeProviderPermission: Could not create message: ' + e.message)
			}
		},
		
		msgCreateRelease({ value }: msgCreateReleaseParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgCreateRelease", value: MsgCreateRelease.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateRelease: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateUserBio({ value }: msgUpdateUserBioParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateUserBio", value: MsgUpdateUserBio.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateUserBio: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateIssueDescription({ value }: msgUpdateIssueDescriptionParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateIssueDescription", value: MsgUpdateIssueDescription.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateIssueDescription: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateDaoAvatar({ value }: msgUpdateDaoAvatarParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateDaoAvatar", value: MsgUpdateDaoAvatar.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateDaoAvatar: Could not create message: ' + e.message)
			}
		},
		
		msgMultiSetBranch({ value }: msgMultiSetBranchParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgMultiSetBranch", value: MsgMultiSetBranch.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgMultiSetBranch: Could not create message: ' + e.message)
			}
		},
		
		msgInvokeMergePullRequest({ value }: msgInvokeMergePullRequestParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgInvokeMergePullRequest", value: MsgInvokeMergePullRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgInvokeMergePullRequest: Could not create message: ' + e.message)
			}
		},
		
		msgAddIssueLabels({ value }: msgAddIssueLabelsParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgAddIssueLabels", value: MsgAddIssueLabels.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAddIssueLabels: Could not create message: ' + e.message)
			}
		},
		
		msgCreateComment({ value }: msgCreateCommentParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgCreateComment", value: MsgCreateComment.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateComment: Could not create message: ' + e.message)
			}
		},
		
		msgUpdatePullRequestDescription({ value }: msgUpdatePullRequestDescriptionParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdatePullRequestDescription", value: MsgUpdatePullRequestDescription.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdatePullRequestDescription: Could not create message: ' + e.message)
			}
		},
		
		msgAddPullRequestReviewers({ value }: msgAddPullRequestReviewersParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgAddPullRequestReviewers", value: MsgAddPullRequestReviewers.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAddPullRequestReviewers: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateTask({ value }: msgUpdateTaskParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateTask", value: MsgUpdateTask.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateTask: Could not create message: ' + e.message)
			}
		},
		
		msgRenameRepository({ value }: msgRenameRepositoryParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgRenameRepository", value: MsgRenameRepository.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRenameRepository: Could not create message: ' + e.message)
			}
		},
		
		msgToggleIssueState({ value }: msgToggleIssueStateParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgToggleIssueState", value: MsgToggleIssueState.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgToggleIssueState: Could not create message: ' + e.message)
			}
		},
		
		msgUnlinkPullRequestIssueByIid({ value }: msgUnlinkPullRequestIssueByIidParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUnlinkPullRequestIssueByIid", value: MsgUnlinkPullRequestIssueByIid.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUnlinkPullRequestIssueByIid: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateRelease({ value }: msgUpdateReleaseParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateRelease", value: MsgUpdateRelease.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateRelease: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteRelease({ value }: msgDeleteReleaseParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgDeleteRelease", value: MsgDeleteRelease.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteRelease: Could not create message: ' + e.message)
			}
		},
		
		msgCreateIssue({ value }: msgCreateIssueParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgCreateIssue", value: MsgCreateIssue.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateIssue: Could not create message: ' + e.message)
			}
		},
		
		msgToggleRepositoryForking({ value }: msgToggleRepositoryForkingParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgToggleRepositoryForking", value: MsgToggleRepositoryForking.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgToggleRepositoryForking: Could not create message: ' + e.message)
			}
		},
		
		msgRemovePullRequestLabels({ value }: msgRemovePullRequestLabelsParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgRemovePullRequestLabels", value: MsgRemovePullRequestLabels.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRemovePullRequestLabels: Could not create message: ' + e.message)
			}
		},
		
		msgForkRepository({ value }: msgForkRepositoryParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgForkRepository", value: MsgForkRepository.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgForkRepository: Could not create message: ' + e.message)
			}
		},
		
		msgToggleCommentResolved({ value }: msgToggleCommentResolvedParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgToggleCommentResolved", value: MsgToggleCommentResolved.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgToggleCommentResolved: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateUserName({ value }: msgUpdateUserNameParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateUserName", value: MsgUpdateUserName.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateUserName: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteBounty({ value }: msgDeleteBountyParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgDeleteBounty", value: MsgDeleteBounty.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteBounty: Could not create message: ' + e.message)
			}
		},
		
		msgCreateDao({ value }: msgCreateDaoParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgCreateDao", value: MsgCreateDao.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateDao: Could not create message: ' + e.message)
			}
		},
		
		msgRenameDao({ value }: msgRenameDaoParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgRenameDao", value: MsgRenameDao.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRenameDao: Could not create message: ' + e.message)
			}
		},
		
		msgAddMember({ value }: msgAddMemberParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgAddMember", value: MsgAddMember.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAddMember: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateIssueTitle({ value }: msgUpdateIssueTitleParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateIssueTitle", value: MsgUpdateIssueTitle.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateIssueTitle: Could not create message: ' + e.message)
			}
		},
		
		msgChangeOwner({ value }: msgChangeOwnerParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgChangeOwner", value: MsgChangeOwner.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgChangeOwner: Could not create message: ' + e.message)
			}
		},
		
		msgCreateRepositoryLabel({ value }: msgCreateRepositoryLabelParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgCreateRepositoryLabel", value: MsgCreateRepositoryLabel.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateRepositoryLabel: Could not create message: ' + e.message)
			}
		},
		
		msgCreateTask({ value }: msgCreateTaskParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgCreateTask", value: MsgCreateTask.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateTask: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteBranch({ value }: msgDeleteBranchParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgDeleteBranch", value: MsgDeleteBranch.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteBranch: Could not create message: ' + e.message)
			}
		},
		
		msgCreatePullRequest({ value }: msgCreatePullRequestParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgCreatePullRequest", value: MsgCreatePullRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreatePullRequest: Could not create message: ' + e.message)
			}
		},
		
		msgInvokeForkRepository({ value }: msgInvokeForkRepositoryParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgInvokeForkRepository", value: MsgInvokeForkRepository.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgInvokeForkRepository: Could not create message: ' + e.message)
			}
		},
		
		msgRemoveIssueLabels({ value }: msgRemoveIssueLabelsParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgRemoveIssueLabels", value: MsgRemoveIssueLabels.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRemoveIssueLabels: Could not create message: ' + e.message)
			}
		},
		
		msgDistributePlatformIncentives({ value }: msgDistributePlatformIncentivesParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgDistributePlatformIncentives", value: MsgDistributePlatformIncentives.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDistributePlatformIncentives: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateComment({ value }: msgUpdateCommentParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateComment", value: MsgUpdateComment.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateComment: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteUser({ value }: msgDeleteUserParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgDeleteUser", value: MsgDeleteUser.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteUser: Could not create message: ' + e.message)
			}
		},
		
		msgLinkPullRequestIssueByIid({ value }: msgLinkPullRequestIssueByIidParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgLinkPullRequestIssueByIid", value: MsgLinkPullRequestIssueByIid.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgLinkPullRequestIssueByIid: Could not create message: ' + e.message)
			}
		},
		
		msgAddIssueAssignees({ value }: msgAddIssueAssigneesParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgAddIssueAssignees", value: MsgAddIssueAssignees.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAddIssueAssignees: Could not create message: ' + e.message)
			}
		},
		
		msgExercise({ value }: msgExerciseParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgExercise", value: MsgExercise.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgExercise: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateUserPinnedRepositories({ value }: msgUpdateUserPinnedRepositoriesParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateUserPinnedRepositories", value: MsgUpdateUserPinnedRepositories.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateUserPinnedRepositories: Could not create message: ' + e.message)
			}
		},
		
		msgRemoveMember({ value }: msgRemoveMemberParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgRemoveMember", value: MsgRemoveMember.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRemoveMember: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateBountyExpiry({ value }: msgUpdateBountyExpiryParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateBountyExpiry", value: MsgUpdateBountyExpiry.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateBountyExpiry: Could not create message: ' + e.message)
			}
		},
		
		msgRemovePullRequestReviewers({ value }: msgRemovePullRequestReviewersParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgRemovePullRequestReviewers", value: MsgRemovePullRequestReviewers.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRemovePullRequestReviewers: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteComment({ value }: msgDeleteCommentParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgDeleteComment", value: MsgDeleteComment.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteComment: Could not create message: ' + e.message)
			}
		},
		
		msgCloseBounty({ value }: msgCloseBountyParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgCloseBounty", value: MsgCloseBounty.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCloseBounty: Could not create message: ' + e.message)
			}
		},
		
		msgRemoveIssueAssignees({ value }: msgRemoveIssueAssigneesParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgRemoveIssueAssignees", value: MsgRemoveIssueAssignees.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRemoveIssueAssignees: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateDaoWebsite({ value }: msgUpdateDaoWebsiteParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateDaoWebsite", value: MsgUpdateDaoWebsite.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateDaoWebsite: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateRepositoryDescription({ value }: msgUpdateRepositoryDescriptionParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateRepositoryDescription", value: MsgUpdateRepositoryDescription.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateRepositoryDescription: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateRepositoryBackupRef({ value }: msgUpdateRepositoryBackupRefParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateRepositoryBackupRef", value: MsgUpdateRepositoryBackupRef.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateRepositoryBackupRef: Could not create message: ' + e.message)
			}
		},
		
		msgSetDefaultBranch({ value }: msgSetDefaultBranchParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgSetDefaultBranch", value: MsgSetDefaultBranch.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSetDefaultBranch: Could not create message: ' + e.message)
			}
		},
		
		msgAddPullRequestAssignees({ value }: msgAddPullRequestAssigneesParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgAddPullRequestAssignees", value: MsgAddPullRequestAssignees.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAddPullRequestAssignees: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParams({ value }: msgUpdateParamsParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateParams", value: MsgUpdateParams.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message)
			}
		},
		
		msgToggleForcePush({ value }: msgToggleForcePushParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgToggleForcePush", value: MsgToggleForcePush.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgToggleForcePush: Could not create message: ' + e.message)
			}
		},
		
		msgToggleArweaveBackup({ value }: msgToggleArweaveBackupParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgToggleArweaveBackup", value: MsgToggleArweaveBackup.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgToggleArweaveBackup: Could not create message: ' + e.message)
			}
		},
		
		msgUpdatePullRequestTitle({ value }: msgUpdatePullRequestTitleParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdatePullRequestTitle", value: MsgUpdatePullRequestTitle.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdatePullRequestTitle: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateDaoDescription({ value }: msgUpdateDaoDescriptionParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateDaoDescription", value: MsgUpdateDaoDescription.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateDaoDescription: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteIssue({ value }: msgDeleteIssueParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgDeleteIssue", value: MsgDeleteIssue.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteIssue: Could not create message: ' + e.message)
			}
		},
		
		msgCreateBounty({ value }: msgCreateBountyParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgCreateBounty", value: MsgCreateBounty.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateBounty: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteDao({ value }: msgDeleteDaoParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgDeleteDao", value: MsgDeleteDao.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteDao: Could not create message: ' + e.message)
			}
		},
		
		msgCreateRepository({ value }: msgCreateRepositoryParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgCreateRepository", value: MsgCreateRepository.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateRepository: Could not create message: ' + e.message)
			}
		},
		
		msgRemovePullRequestAssignees({ value }: msgRemovePullRequestAssigneesParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgRemovePullRequestAssignees", value: MsgRemovePullRequestAssignees.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRemovePullRequestAssignees: Could not create message: ' + e.message)
			}
		},
		
		msgAddRepositoryBackupRef({ value }: msgAddRepositoryBackupRefParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgAddRepositoryBackupRef", value: MsgAddRepositoryBackupRef.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAddRepositoryBackupRef: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateDaoPinnedRepositories({ value }: msgUpdateDaoPinnedRepositoriesParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateDaoPinnedRepositories", value: MsgUpdateDaoPinnedRepositories.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateDaoPinnedRepositories: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateRepositoryCollaborator({ value }: msgUpdateRepositoryCollaboratorParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateRepositoryCollaborator", value: MsgUpdateRepositoryCollaborator.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateRepositoryCollaborator: Could not create message: ' + e.message)
			}
		},
		
		msgRemoveRepositoryCollaborator({ value }: msgRemoveRepositoryCollaboratorParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgRemoveRepositoryCollaborator", value: MsgRemoveRepositoryCollaborator.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRemoveRepositoryCollaborator: Could not create message: ' + e.message)
			}
		},
		
		msgAuthorizeProvider({ value }: msgAuthorizeProviderParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgAuthorizeProvider", value: MsgAuthorizeProvider.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAuthorizeProvider: Could not create message: ' + e.message)
			}
		},
		
		msgMultiDeleteBranch({ value }: msgMultiDeleteBranchParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgMultiDeleteBranch", value: MsgMultiDeleteBranch.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgMultiDeleteBranch: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateRepositoryLabel({ value }: msgUpdateRepositoryLabelParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateRepositoryLabel", value: MsgUpdateRepositoryLabel.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateRepositoryLabel: Could not create message: ' + e.message)
			}
		},
		
		msgCreateUser({ value }: msgCreateUserParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgCreateUser", value: MsgCreateUser.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateUser: Could not create message: ' + e.message)
			}
		},
		
		msgSetPullRequestState({ value }: msgSetPullRequestStateParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgSetPullRequestState", value: MsgSetPullRequestState.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSetPullRequestState: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateDaoLocation({ value }: msgUpdateDaoLocationParams): EncodeObject {
			try {
				return { typeUrl: "/gitopia.gitopia.gitopia.MsgUpdateDaoLocation", value: MsgUpdateDaoLocation.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateDaoLocation: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	public structure: Record<string,unknown>;
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		this.structure =  {
						Attachment: getStructure(typeAttachment.fromPartial({})),
						Bounty: getStructure(typeBounty.fromPartial({})),
						Branch: getStructure(typeBranch.fromPartial({})),
						Comment: getStructure(typeComment.fromPartial({})),
						Dao: getStructure(typeDao.fromPartial({})),
						ExercisedAmount: getStructure(typeExercisedAmount.fromPartial({})),
						Issue: getStructure(typeIssue.fromPartial({})),
						Member: getStructure(typeMember.fromPartial({})),
						DistributionProportion: getStructure(typeDistributionProportion.fromPartial({})),
						PoolProportions: getStructure(typePoolProportions.fromPartial({})),
						Params: getStructure(typeParams.fromPartial({})),
						PullRequest: getStructure(typePullRequest.fromPartial({})),
						PullRequestHead: getStructure(typePullRequestHead.fromPartial({})),
						PullRequestBase: getStructure(typePullRequestBase.fromPartial({})),
						QueryGetPullRequestRequest: getStructure(typeQueryGetPullRequestRequest.fromPartial({})),
						QueryGetPullRequestResponse: getStructure(typeQueryGetPullRequestResponse.fromPartial({})),
						IssueOptions: getStructure(typeIssueOptions.fromPartial({})),
						PullRequestOptions: getStructure(typePullRequestOptions.fromPartial({})),
						RepositoryFork: getStructure(typeRepositoryFork.fromPartial({})),
						Reaction: getStructure(typeReaction.fromPartial({})),
						Release: getStructure(typeRelease.fromPartial({})),
						Repository: getStructure(typeRepository.fromPartial({})),
						RepositoryId: getStructure(typeRepositoryId.fromPartial({})),
						BaseRepositoryKey: getStructure(typeBaseRepositoryKey.fromPartial({})),
						RepositoryOwner: getStructure(typeRepositoryOwner.fromPartial({})),
						IssueIid: getStructure(typeIssueIid.fromPartial({})),
						PullRequestIid: getStructure(typePullRequestIid.fromPartial({})),
						RepositoryCollaborator: getStructure(typeRepositoryCollaborator.fromPartial({})),
						RepositoryLabel: getStructure(typeRepositoryLabel.fromPartial({})),
						RepositoryRelease: getStructure(typeRepositoryRelease.fromPartial({})),
						RepositoryBackup: getStructure(typeRepositoryBackup.fromPartial({})),
						Tag: getStructure(typeTag.fromPartial({})),
						Task: getStructure(typeTask.fromPartial({})),
						MsgDeleteStorageProviderResponse: getStructure(typeMsgDeleteStorageProviderResponse.fromPartial({})),
						MsgSetBranch_Branch: getStructure(typeMsgSetBranch_Branch.fromPartial({})),
						MsgMultiSetBranch_Branch: getStructure(typeMsgMultiSetBranch_Branch.fromPartial({})),
						MsgSetTag_Tag: getStructure(typeMsgSetTag_Tag.fromPartial({})),
						MsgMultiSetTag_Tag: getStructure(typeMsgMultiSetTag_Tag.fromPartial({})),
						MsgDistributePlatformIncentives_Address: getStructure(typeMsgDistributePlatformIncentives_Address.fromPartial({})),
						User: getStructure(typeUser.fromPartial({})),
						UserDao: getStructure(typeUserDao.fromPartial({})),
						Whois: getStructure(typeWhois.fromPartial({})),
						
		};
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const Module = (test: IgniteClient) => {
	return {
		module: {
			GitopiaGitopiaGitopia: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default Module;